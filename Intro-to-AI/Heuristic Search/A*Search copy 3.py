import random
import heapq
import copy

class Puzzle:

    # puzzle constructor: creates a puzzle of size n, if no state is inputed, then the constructor defaults to a random state generation
    def __init__(self, size, g_cost, state=None):

        #this generates the goal state, which is the ordered puzzle, where 0 is at the beginning
        goal_state = [[i + j * size for i in range(size)] for j in range(size)]

        self.size = size

        #if state is none generate a puzzle with scattered tiles
        if state == None:
            self.state = self.generate_random_puzzle()
        else:
            self.state = state

        self.goal_state = goal_state

        #this calculates the total cost of the action
        self.g_cost = g_cost
        self.f_cost = self.g_cost + self.h1()


    #Overwriting the __repr__ function enables me to print the array in the desired format, addtionally tiles in the correct 
    # postion are green and tiles in the incorrect postion are red
    def __repr__(self):

        #the following color values were generated by ChatGPT!
        green = '\033[92m'
        red = '\033[91m'
        reset = '\033[0m'

        result = [] #final result matrix

        for row_index, row in enumerate(self.state):
            colored_row = [] # for each row we create an equivalent colored_row
            for col_index, tile in enumerate(row):
                if tile == self.goal_state[row_index][col_index]: #check whether the current tile is in the coresponding position of the goal state
                    colored_row.append(f'{green}{tile}{reset}') #if so color green
                elif tile == 0:
                    colored_row.append(f'{tile}')
                else:
                    colored_row.append(f'{red}{tile}{reset}') # if not color red
            result.append(' '.join(colored_row)) #append row to the result
        return '\n'.join(result) #print the result, while making sure to new line, when end of row is reached
    
    def __lt__(self, other):
        return self.f_cost < other.f_cost
    
    def state_tuple(self):
        return tuple(tuple(row) for row in self.state)
    
    def generate_random_puzzle(self):

        def count_inversions(puzzle):
            one_d_puzzle = [tile for row in puzzle for tile in row]
            inversions = 0
            for i in range(len(one_d_puzzle) - 1):
                for j in range(i + 1, len(one_d_puzzle)):
                    if one_d_puzzle[i] > one_d_puzzle[j] and one_d_puzzle[i] != 0 and one_d_puzzle[j] != 0:
                        inversions += 1
            return inversions
    
        def is_solvable(puzzle, n):
            # Get the row of the blank space (0 represents the blank space)
            flat_puzzle = [tile for row in puzzle for tile in row]
            blank_pos = flat_puzzle.index(0)
            blank_row = blank_pos // n
            inversions = count_inversions(puzzle)
    
            # Apply the solvability conditions
            if n % 2 == 1:  # Odd-sized grids (3x3, 5x5, etc.)
                return inversions % 2 == 0
            else:  # Even-sized grids (4x4, 6x6, 8x8, etc.)
                if blank_row % 2 == 0:
                    return inversions % 2 == 1
                else:
                    return inversions % 2 == 0
                
        while True:
            # Create a list of numbers from 1 to n^2-1, and 0 for the blank space
            puzzle = list(range(self.size**2))
            random.shuffle(puzzle)  # Shuffle the puzzle
            puzzle = [puzzle[i:i + self.size] for i in range(0, len(puzzle), self.size)]  # Convert to n x n grid
        
            # Check if the generated puzzle is solvable
            if is_solvable(puzzle, self.size):
                return puzzle


    def h1(self):
        '''
        input: the state that the heuristic should be applied to

        purpose: implements the h1 heuristic, which calculates the total number of misplaced tiles in a given state

        return: the total number of misplaced tiles
        '''
        total_counter = 0
        #print('new call')
        #print(self.state)
        #print(self.goal_state)
        for row1, row2 in zip(self.state, self.goal_state):
            misplaced_tiles = sum([1 for a,b in zip(row1, row2) if a != b])
            total_counter += misplaced_tiles
        return total_counter
    
    def h2(self):
        manhattan_distance = 0

        goal_positions = {value: (r, c) for r, row in enumerate(self.goal_state) for c, value in enumerate(row)}

        for r, row in enumerate(self.state):
            for c, value in enumerate(row):
                goal_r, goal_c = goal_positions[value]
                manhattan_distance += abs(goal_r - r) + abs(goal_c - c)

        return manhattan_distance
    
    def generate_children(self, g_cost, h):

        '''
        purpose: generate a priority queue of the neighboring nodes

        return: the heap queue
        '''

        children = []

        #locate 0
        for y_ix, row in enumerate(self.state):
            for x_ix, tile in enumerate(row):
                if tile == 0:
                    location_0 = {'y': y_ix, 'x': x_ix}

        #up-move
        if location_0['y'] > 0:
            UP_puzzle = Puzzle(self.size, g_cost, copy.deepcopy(self.state))
            UP_puzzle.state[location_0['y']][location_0['x']] = UP_puzzle.state[location_0['y'] - 1][location_0['x']]
            UP_puzzle.state[location_0['y'] - 1][location_0['x']] = 0
            UP_puzzle.f_cost = calculate_f(UP_puzzle, h)
            children.append((UP_puzzle.f_cost, UP_puzzle))

        #down-move
        if location_0['y'] < self.size - 1:
            DOWN_puzzle = Puzzle(self.size, g_cost, copy.deepcopy(self.state))
            DOWN_puzzle.state[location_0['y']][location_0['x']] = DOWN_puzzle.state[location_0['y'] + 1][location_0['x']]
            DOWN_puzzle.state[location_0['y'] + 1][location_0['x']] = 0
            DOWN_puzzle.f_cost = calculate_f(DOWN_puzzle, h)
            children.append((DOWN_puzzle.f_cost, DOWN_puzzle))

        #right-move
        if location_0['x'] < self.size - 1:
            RIGHT_puzzle = Puzzle(self.size, g_cost, copy.deepcopy(self.state))
            RIGHT_puzzle.state[location_0['y']][location_0['x']] = RIGHT_puzzle.state[location_0['y']][location_0['x'] + 1]
            RIGHT_puzzle.state[location_0['y']][location_0['x'] + 1] = 0
            RIGHT_puzzle.f_cost = calculate_f(RIGHT_puzzle, h)
            children.append((RIGHT_puzzle.f_cost, RIGHT_puzzle))

        #left-move
        if location_0['x'] > 0:
            LEFT_puzzle = Puzzle(self.size, g_cost, copy.deepcopy(self.state))
            LEFT_puzzle.state[location_0['y']][location_0['x']] = LEFT_puzzle.state[location_0['y']][location_0['x'] - 1]
            LEFT_puzzle.state[location_0['y']][location_0['x'] - 1] = 0
            LEFT_puzzle.f_cost = calculate_f(LEFT_puzzle, h)
            children.append((LEFT_puzzle.f_cost, LEFT_puzzle))

        return children
    
    

class A_Star:

    def __init__(self, start_puzzle, stoppage_criterion, h):
        self.curr_puzzle = start_puzzle
        self.depth = 0
        self.goal_state = start_puzzle.goal_state

        self.closed_set = set()

        self.h = h

        start_puzzle.f_cost = calculate_f(start_puzzle, self.h)
        self.frontier = [(start_puzzle.f_cost, start_puzzle)]

        heapq.heapify(self.frontier)

        self.parents = {}

        self.number_of_nodes = 0

        self.stoppage_criterion = stoppage_criterion

    def search(self):

        #Impemplements a heap-priority queue to iterate over the search space

        print(self.goal_state)

        while(self.frontier and self.number_of_nodes < self.stoppage_criterion):
            
            _, current_puzzle = heapq.heappop(self.frontier)

            if current_puzzle.state == self.goal_state:
                print('solution found')
                return self.reconstruct_path(current_puzzle)
            
            self.closed_set.add(current_puzzle.state_tuple())

            children = current_puzzle.generate_children(current_puzzle.g_cost + 1, self.h)
            
            for puzzle in children:

                self.number_of_nodes += 1

                if puzzle[1].state_tuple() in self.closed_set:
                    #print('puzzle already explored, not considered!')
                    continue
            
                heapq.heappush(self.frontier, puzzle)

                self.parents[puzzle[1].state_tuple()] = current_puzzle

        print(f'Stoppage Criterion Reached. More than {self.stoppage_criterion} nodes generated')

    def reconstruct_path(self, goal_puzzle):
        print('reconstructing path')
        path = []
        current_puzzle = goal_puzzle
        while current_puzzle:
            path.append(current_puzzle)
            current_puzzle = self.parents.get(current_puzzle.state_tuple())
        path.reverse()
        return path
    
def calculate_f(puzzle, h):
    if h == 'misplace':
        return puzzle.g_cost + puzzle.h1()
    else:
        return puzzle.g_cost + puzzle.h2()
            
example_8puzzle = [[2, 5, 3],
                   [4, 1, 6],
                   [7, 0, 8]]

example_easy_puzzle = [[1, 0, 2],
                       [3, 4, 5],
                       [6, 7, 8]]

puzzle_2x2 = [[1, 3],
              [2, 0]]

puzzle_4x4 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 12, 11],
    [13, 14, 15, 0]
]

examp = Puzzle(3, 0)

Find_sol = A_Star(examp, 10000000, 'manhattan')
solution = Find_sol.search()

if solution != None:
    print('solution start')
    for step in solution:
        print(step)
        print('\n')

    print('# of nodes generated: ', Find_sol.number_of_nodes)
    print('solution length d: ', len(solution))